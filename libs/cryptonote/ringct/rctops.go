package ringct

import "C"
import (
	. "github.com/lianxiangcloud/linkchain/libs/cryptonote/types"
	"github.com/lianxiangcloud/linkchain/libs/cryptonote/xcrypto"
)

var Z = Key{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
var I = Key{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
var L = Key{0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}
var G = Key{0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66}
var EIGHT = Key{0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
var INV_EIGHT = Key{0x79, 0x2f, 0xdc, 0xe2, 0x29, 0xe5, 0x06, 0x61, 0xd0, 0xda, 0x1c, 0x7d, 0xb3, 0x9d, 0xd3, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06}
var H = Key{0x8b, 0x65, 0x59, 0x70, 0x15, 0x37, 0x99, 0xaf, 0x2a, 0xea, 0xdc, 0x9f, 0xf1, 0xad, 0xd0, 0xea, 0x6c, 0x72, 0x51, 0xd5, 0x41, 0x54, 0xcf, 0xa9, 0x2c, 0x17, 0x3a, 0x0d, 0xd3, 0x9c, 0x1f, 0x94}

func Identity() Key {
	return I
}

func CurveOrder() Key {
	return L
}
func Zero() Key {
	return Z
}

//does a * G where a is a scalar and G is the curve basepoint
func ScalarmultBase(a Key) Key {
	return xcrypto.ScalarmultBase(a)
}

//does a * P where a is a scalar and P is an arbitrary point
func ScalarmultKey(p, a Key) (Key, error) {
	return xcrypto.ScalarmultKey(p, a)
}

//generates a random secret and corresponding public key
func SkpkGen() (sk Key, pk Key) {
	return xcrypto.SkpkGen()
}

//Computes aH where H= toPoint(cn_fast_hash(G)), G the basepoint
func ScalarmultH(key Key) Key {
	return xcrypto.ScalarmultH(key)
}

func ZeroCommit(amount Lk_amount) (Key, error) {
	return xcrypto.ZeroCommit(amount)
}

func EcdhEncode(masked *EcdhTuple, sharedSec Key, shortAmount bool) bool {
	return xcrypto.EcdhEncode(masked, sharedSec, shortAmount)
}

//Computes 8P
func Scalarmult8(p Key) (ret Key, _ error) {
	return xcrypto.Scalarmult8(p)
}
func ScAdd(a, b EcScalar) (ret Key) {
	return xcrypto.ScAdd(a, b)
}

func ScSub(a, b EcScalar) (ret Key) {
	return xcrypto.ScSub(a, b)
}
func SkGen() (ret Key) {
	return xcrypto.SkGen()
}
func GenC(a Key, amount Lk_amount) (ret Key, _ error) {
	return xcrypto.GenC(a, amount)
}

func AddKeys(a, b Key) (Key, error) {
	return xcrypto.AddKeys(a, b)
}

func AddKeyV(a KeyV) (Key, error) {
	return xcrypto.TlvAddKeyV(a)
}

func AddKeys2(a, b, B Key) (Key, error) {
	return xcrypto.AddKeys2(a, b, B)
}
